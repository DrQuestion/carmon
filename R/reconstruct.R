#' Reconstruct a multi-omics network from a list of copulized layers
#'
#' Reconstruct a multi-omics network from a list of copulized layers with a
#' chosen network reconstruction method. The default method is
#' \emph{collaborative graphical regression}.
#'
#' `reconstruct()` uses \emph{collaborative graphical lasso} ('coglasso') as a
#' default engine to reconstruct the multi-omics network, as the method was
#' specifically developed for the multi-omics scenario. `carmon` also implements
#' three classic alternatives to 'coglasso': \emph{graphical lasso},
#' neighborhood selection (as designed by Meinshausen and Buhlmann), and
#' Pearson's correlation networks. The computational engine mainly used for
#' these alternative options is the `huge` R package for network reconstruction,
#' with a couple of small exceptions. Each one of these methods comes with its
#' tailored model selection procedures. For 'coglasso', for example, it is an
#' StARS procedure extended to the multiple hyperparameters of coglasso,
#' \emph{XStARS}, while for the other methods we suggest using the traditional
#' \emph{StARS} strategy.
#'
#' @param layers The omics layers to analyze. To be provided as a named R
#'   list of data sets that have undergone the copulization treatment by the
#'   `copulize()` function. Given the output  of `copulize()`, for example an
#'   object named `carmon_cop`, it can be accessed via `carmon_cop$layers`.
#' @param net_method The network reconstruction method to use. The four methods
#'   currently available are: 'coglasso' for collaborative graphical lasso,
#'   'glasso' for graphical lasso, 'mb' for the Meinshausen-Buhlmann
#'   neighborhood selection, and 'correlation' for a thresholded Pearson's
#'   correlation network. The default method is 'coglasso'.
#' @param sel_method The network selection method. Each reconstruction procedure
#'   has its own model selection procedures available. Here is the list of them:
#'   * for `net_method` being 'coglasso': 'xstars' for eXtended StARS, 'xestars'
#'   for eXtended  Efficient StARS, and 'ebic' for extended bayesian information
#'   criterion. Default is 'xestars'.
#'   * for `net_method` being 'glasso': 'stars' for StARS, 'ric' for rotational
#'   information criterion, and 'ebic' for for extended bayesian information
#'   criterion. Default is 'stars'.
#'   * for `net_method` being 'mb' or 'correlation': 'stars' for StARS, 'ric'
#'   for rotational information criterion. Default is 'stars'.
#' @param ... The additional optional arguments to be given for the network
#'   reconstruction procedure. The available arguments depend on the chosen
#'   network reconstruction and network selection methods. If using 'coglasso'
#'   (default option), see [coglasso::bs()] for both reconstruction and
#'   selection arguments. If reconstructing with 'glasso', 'mb', or
#'   'correlation' without setting `cor_cutoff` or `cor_quant` see,
#'   respectively, [huge::huge.glasso()], [huge::huge.mb()], or
#'   [huge::huge.ct()]. For additional options for network selection from these
#'   last three reconstruction methods, see [huge::huge.select()].
#' @param cor_cutoff Optional for `net_method = 'correlation'`. The cutoff
#'   value for the absolute Pearson's correlation network. Any edge with an
#'   absolute correlation below the cutoff is excluded from the final network.
#'   Not used by default, as the cutoff is generated by internal calculations.
#' @param cor_quant Optional for `net_method = 'correlation'`, to set as an
#'   alternative to `cor_cutoff`. Determine the cutoff of correlation based on
#'   the top percentile indicated by the user. For example, `cor_quant = 0.2`
#'   would set as a correlation cutoff the 20th percentile of the absolute
#'   Pearson's correlation values, ordered from highest to lowest. Not used by
#'   default, as the cutoff is generated by internal calculations.
#' @param minimal_output Logical. Set to TRUE to get only a minimal output from
#'   the `reconstruct()` function, which differs depending on the network
#'   reconstruction method.
#' @param verbose The level of verbosity of the reconstruction process. `0`
#'   suppresses the information output, while `1` and `2` give progressively
#'   increasing amounts of information about the inner computations happening
#'   inside `reconstruct()`.
#'
#' @returns `reconstruct()` returns an object of `S3` class `carmon_rec`. The
#' elements it contains depend on the chosen network reconstruction and
#' selection strategies, but the main elements are shared by all methods. \cr
#' These shared elements are:
#' \itemize{
#'   \item `sel_adj` is the adjacency matrix of the final selected network.
#'   \item `net_method` is the chosen network reconstruction method.
#'   \item `sel_method` is the chosen model selection method.
#'   \item `reconstruct_call` is the matched call.
#' }
#'
#' Moreover, when choosing 'coglasso' or 'glasso' as network reconstruction
#' method, `reconstruct()` also returns:
#'
#' \itemize{
#'   \item `sel_icov` is the inverse covariance matrix of the final selected
#'     network.
#' }
#'
#' Otherwise, if choosing 'correlation', it returns:
#'
#' \itemize{
#'   \item `cor` is the Pearson's correlation matrix of the final selected
#'     network.
#' }
#'
#' When `minimal_output` is set to TRUE, these are also the only elements
#' returned in the object of class `carmon_rec` given by `reconstruct()`. For
#' the non minimal output elements, please look at [coglasso::bs()] for
#' `net_method = 'coglasso'`. For the other three methods, look at
#' [huge::huge()] and at [huge::huge.select()].
#'
#' @export
#'
#' @examples
#' # To reconstruct the multi-omics network, it is first necessary to copulize
#' # the input data with copulize(), then provide the normally distributed
#' # omics layers to reconstruct().
#' data(multi_omics_micro)
#' copulized <- copulize(multi_omics_micro)
#' rec <- reconstruct(copulized$layers,
#'     net_method = "correlation",
#'     cor_quant = 0.5, verbose = FALSE
#' )
#'
#' # To make a carmon object out of these two:
#' c_obj <- assemble_carmon_obj(copulized, rec)
#'
reconstruct <- function(layers, net_method = "coglasso", sel_method = NULL, ...,
                        cor_cutoff = NULL, cor_quant = NULL,
                        minimal_output = FALSE, verbose = FALSE) {
    p <- vapply(layers, ncol, numeric(1))

    verbose_inner <- FALSE
    if (verbose > 1) verbose_inner <- TRUE
    if (verbose) {
        message("***********Beginning network reconstruction***********")
        flush.console()
    }
    layers <- merge_layers(layers)
    if (net_method == "coglasso") {
        rec <- reconstruct_cg(layers, p = p, sel_method = sel_method, ...,
                            verbose = verbose, verbose_inner = verbose_inner)
    } else if (net_method == "glasso") {
        rec <- reconstruct_g(layers, sel_method = sel_method, ...,
                            verbose = verbose, verbose_inner = verbose_inner)
    } else if (net_method == "correlation") {
        if (is.null(cor_quant) && is.null(cor_cutoff)) {
            # Use huge correlation thresholding
            rec <- reconstruct_ct(layers, sel_method = sel_method, ...,
                            verbose = verbose, verbose_inner = verbose_inner)
        } else {
            rec <- reconstruct_cor(layers, cor_cutoff = cor_cutoff,
                                    cor_quant = cor_quant, verbose = verbose)
        }
    } else if (net_method == "mb") {
        rec <- reconstruct_mb(layers, sel_method = sel_method, ...,
                            verbose = verbose, verbose_inner = verbose_inner)
    }
    if (minimal_output) {
        non_minimal <- which(!(names(rec) %in% c("sel_adj", "sel_icov", "cor",
                                                "sel_method")))
        rec[non_minimal] <- NULL
    } else {
        rec$method <- NULL
    }
    rec$net_method <- net_method
    rec$reconstruct_call <- match.call()
    class(rec) <- "carmon_rec"
    if (verbose) {
        message("***********Network reconstruction complete************\n")
        flush.console()
    }
    return(rec)
}

#' Reconstruct and select a coglasso network
#'
#' @param layers The omics layers to analyze. To be provided as a merged data
#'   set of the layers that have undergone the copulization treatment by the
#'   `copulize()` function. Given the output  of `copulize()`, for example an
#'   object named `carmon_cop`, it can be accessed via
#'   `merge_layers(carmon_cop$layers)`.
#' @param p The number of features in each omics layer.
#' @param sel_method The network selection method. Use 'xstars' for eXtended
#'   StARS, 'xestars' for eXtended Efficient StARS, and 'ebic' for extended
#'   bayesian information criterion. Default is 'xestars'.
#' @param ... The additional optional arguments to be given for the network
#'   reconstruction procedure, see [coglasso::bs()] for both reconstruction and
#'   selection arguments.
#' @param verbose The level of verbosity of the reconstruction process. `0`
#'   suppresses the information output, while `1` and `2` give progressively
#'   increasing amounts of information about the inner computations.
#' @param verbose_inner Whether the inner reconstruction and selection methods
#'   should be verbose or not.
#'
#' @returns This function returns an R list with the following elements:
#' \itemize{
#'   \item `sel_adj` is the adjacency matrix of the final selected network.
#'   \item `net_method` is the chosen network reconstruction method.
#'   \item `sel_method` is the chosen model selection method.
#'   \item `sel_icov` is the inverse covariance matrix of the final selected
#'     network.
#' }
#' For the additional output elements, please look at [coglasso::bs()].
#'
#' @noRd
#'
reconstruct_cg <- function(layers, p = NULL, sel_method = NULL, ...,
                            verbose = FALSE, verbose_inner = FALSE) {
    if (is.null(sel_method)) {
        sel_method <- "xestars"
    } else if ("method" %in% names(list(...))) {
        warning("Selection method was provided twice: as sel_method and as
    method. sel_method will overwrite method")
    }
    if (!(sel_method %in% c("xstars", "xestars", "ebic"))) {
        stop("sel_method for coglasso should be one between 'xstars',
    'xestars', or 'ebic'")
    }
    if (verbose > 0 & verbose < 2) {
        message("Reconstructing network with coglasso",
                ", selecting the optimal one with ", sel_method, "....")
        flush.console()
    }
    valid_args <- filter_args(coglasso::bs, list(...))
    valid_args$data <- layers
    valid_args$p <- p
    valid_args$method <- sel_method
    valid_args$verbose <- verbose_inner
    if (length(p) > 2) {
        # Until multiple data sets issue is solved for D > 2, c is forced
        # to 0
        if ("c" | "nc" | "c_max" | "c_min_ratio" %in% names(valid_args)) {
            warning("Argument 'c' was detected with more than two omics
    layers. coglasso can be run only for c = 0 with more
    than two layers.")
        }
        valid_args$c <- 0
        rec <- do.call(coglasso::bs, valid_args)
    } else {
        rec <- do.call(coglasso::bs, valid_args)
    }
    if (verbose > 0 & verbose < 2) {
        message("Optimal network selected!")
        flush.console()
    }
    rec$sel_method <- sel_method
    return(rec)
}

#' Reconstruct and select a glasso network
#'
#' @param layers The omics layers to analyze. To be provided as a merged data
#'   set of the layers that have undergone the copulization treatment by the
#'   `copulize()` function. Given the output  of `copulize()`, for example an
#'   object named `carmon_cop`, it can be accessed via
#'   `merge_layers(carmon_cop$layers)`.
#' @param sel_method The network selection method. Use 'stars' for StARS, 'ric'
#'   for rotational information criterion, and 'ebic' for for extended bayesian
#'   information criterion. Default is 'stars'.
#' @param ... The additional optional arguments to be given for the network
#'   reconstruction procedure, see [huge::huge.glasso()] for the network
#'   reconstruction. For additional options for network selection, see
#'   [huge::huge.select()].
#' @param verbose The level of verbosity of the reconstruction process. `0`
#'   suppresses the information output, while `1` and `2` give progressively
#'   increasing amounts of information about the inner computations.
#' @param verbose_inner Whether the inner reconstruction and selection methods
#'   should be verbose or not.
#'
#' @returns This function returns an R list with the following elements:
#' \itemize{
#'   \item `sel_adj` is the adjacency matrix of the final selected network.
#'   \item `net_method` is the chosen network reconstruction method.
#'   \item `sel_method` is the chosen model selection method.
#'   \item `sel_icov` is the inverse covariance matrix of the final selected
#'     network.
#' }
#' For the additional output elements, please look at [huge::huge()] and at
#' [huge::huge.select()].
#'
#' @noRd
#'
reconstruct_g <- function(layers, sel_method = NULL, ...,
                            verbose = FALSE, verbose_inner = FALSE) {
    if (is.null(sel_method) && !("criterion" %in% names(list(...)))) {
        sel_method <- "stars"
    } else if (is.null(sel_method) && "criterion" %in% names(list(...))) {
        args <- list(...)
        sel_method <- args$criterion
    } else if ("criterion" %in% names(list(...))) {
        warning("Selection method was provided twice: as sel_method and as
    criterion. sel_method will overwrite criterion")
    }
    if (!(sel_method %in% c("stars", "ric", "ebic"))) {
        stop("sel_method for glasso should be one between 'stars', 'ric', or
    'ebic'")
    }
    if (verbose > 0 & verbose < 2) {
        message("Reconstructing network with glasso",
                ", selecting the optimal one with ", sel_method, "....")
        flush.console()
    }
    # Build glasso networks with huge
    valid_args <- filter_args(huge::huge.glasso, list(...))
    valid_args$x <- layers
    valid_args$verbose <- verbose_inner
    rec <- do.call(huge::huge.glasso, valid_args)
    rec$data <- layers
    rec$method <- "glasso"
    # Select network
    valid_args <- filter_args(huge::huge.select, list(...))
    valid_args$est <- rec
    valid_args$criterion <- sel_method
    valid_args$verbose <- verbose_inner
    rec <- do.call(huge::huge.select, valid_args)
    rec$sel_adj <- rec$refit
    rec$refit <- NULL
    rec$sel_icov <- rec$opt.icov
    rec$opt.icov <- NULL
    if (verbose > 0 & verbose < 2) {
        message("Optimal network selected!")
        flush.console()
    }
    rec$sel_method <- sel_method
    return(rec)
}

#' Reconstruct and select a correlation thresholding network
#'
#' @param layers The omics layers to analyze. To be provided as a merged data
#'   set of the layers that have undergone the copulization treatment by the
#'   `copulize()` function. Given the output  of `copulize()`, for example an
#'   object named `carmon_cop`, it can be accessed via
#'   `merge_layers(carmon_cop$layers)`.
#' @param sel_method The network selection method. Use 'stars' for StARS, 'ric'
#'   for rotational information criterion. Default is 'stars'.
#' @param ... The additional optional arguments to be given for the network
#'   reconstruction procedure, see [huge::huge.ct()] for the network
#'   reconstruction. For additional options for network selection, see
#'   [huge::huge.select()].
#' @param verbose The level of verbosity of the reconstruction process. `0`
#'   suppresses the information output, while `1` and `2` give progressively
#'   increasing amounts of information about the inner computations.
#' @param verbose_inner Whether the inner reconstruction and selection methods
#'   should be verbose or not.
#'
#' @returns This function returns an R list with the following elements:
#' \itemize{
#'   \item `sel_adj` is the adjacency matrix of the final selected network.
#'   \item `net_method` is the chosen network reconstruction method.
#'   \item `sel_method` is the chosen model selection method.
#'   \item `cor` is the Pearson's correlation matrix of the final selected
#'     network.
#' }
#' For the additional output elements, please look at [huge::huge()] and at
#' [huge::huge.select()].
#'
#' @noRd
#'
reconstruct_ct <- function(layers, sel_method = NULL, ..., verbose = FALSE,
                            verbose_inner = FALSE) {
    # Use huge correlation thresholding
    if (is.null(sel_method) && !("criterion" %in% names(list(...)))) {
        sel_method <- "stars"
    } else if (is.null(sel_method) && "criterion" %in% names(list(...))) {
        args <- list(...)
        sel_method <- args$criterion
    } else if ("criterion" %in% names(list(...))) {
        warning("Selection method was provided twice: as sel_method and
    as criterion. sel_method will overwrite criterion")
    }
    if (!(sel_method %in% c("stars", "ric"))) {
        stop("sel_method for correlation should be one between 'stars'
    or 'ric'")
    }
    if (verbose > 0 & verbose < 2) {
        message("Reconstructing network with correlation
    thresholding, selecting the optimal one with ", sel_method, "....")
        flush.console()
    }
    # Build correlation networks with huge
    valid_args <- filter_args(huge::huge.ct, list(...))
    valid_args$x <- layers
    valid_args$verbose <- verbose_inner
    rec <- do.call(huge::huge.ct, valid_args)
    rec$data <- layers
    rec$method <- "ct"
    # Select network
    valid_args <- filter_args(huge::huge.select, list(...))
    valid_args$est <- rec
    valid_args$criterion <- sel_method
    valid_args$verbose <- verbose_inner
    rec <- do.call(huge::huge.select, valid_args)
    rec$sel_adj <- rec$refit
    rec$refit <- NULL
    rec$cor <- stats::cor(layers)
    if (verbose > 0 & verbose < 2) {
        message("Optimal network selected!")
        flush.console()
    }
    rec$sel_method <- sel_method
    return(rec)
}

#' Reconstruct and select a Pearson's correlation network with user-set cutoff
#'
#' @param layers The omics layers to analyze. To be provided as a merged data
#'   set of the layers that have undergone the copulization treatment by the
#'   `copulize()` function. Given the output  of `copulize()`, for example an
#'   object named `carmon_cop`, it can be accessed via
#'   `merge_layers(carmon_cop$layers)`.
#' @param cor_cutoff Optional for `net_method = 'correlation'`. The cutoff
#'   value for the absolute Pearson's correlation network. Any edge with an
#'   absolute correlation below the cutoff is excluded from the final network.
#'   Not used by default, as the cutoff is generated by internal calculations.
#' @param cor_quant Optional for `net_method = 'correlation'`, to set as an
#'   alternative to `cor_cutoff`. Determine the cutoff of correlation based on
#'   the top percentile indicated by the user. For example, `cor_quant = 0.2`
#'   would set as a correlation cutoff the 20th percentile of the absolute
#'   Pearson's correlation values, ordered from highest to lowest. Not used by
#'   default, as the cutoff is generated by internal calculations.
#' @param verbose The level of verbosity of the reconstruction process. `0`
#'   suppresses the information output, while `1` and `2` give progressively
#'   increasing amounts of information about the inner computations.
#'
#' @returns This function returns an R list with the following elements:
#' \itemize{
#'   \item `sel_adj` is the adjacency matrix of the final selected network.
#'   \item `net_method` is the chosen network reconstruction method.
#'   \item `cor` is the Pearson's correlation matrix of the final selected
#'     network.
#' }
#'
#' @noRd
#'
reconstruct_cor <- function(layers, cor_cutoff = NULL, cor_quant = NULL,
                            verbose = FALSE) {
    if (verbose) {
        message("Reconstructing network with Pearson's correlation....")
        flush.console()
    }
    # Directly estimate one correlation network
    cor_mat <- stats::cor(layers)
    rec <- list()
    rec$sel_adj <- cor_mat
    rec$cor <- cor_mat
    diag(rec$sel_adj) <- 0
    if (!is.null(cor_quant)) {
        cor_quant <- cor_quant
        limit_position <- cor_quant * ((nrow(rec$sel_adj)^2) -
                                            nrow(rec$sel_adj))
        cor_cutoff <- sort(abs(rec$sel_adj), decreasing = TRUE)[limit_position]
    }
    if (verbose) {
        message("Correlation cutoff is ", cor_cutoff)
        flush.console()
    }
    above_cutoff <- which(abs(rec$sel_adj) >= cor_cutoff)
    rec$sel_adj[above_cutoff] <- 1
    rec$sel_adj[rec$sel_adj != 1] <- 0
    if (verbose) {
        message("Network reconstructed!")
        flush.console()
    }
    return(rec)
}

#' Reconstruct and select a neighborhood selection network
#'
#' @param layers The omics layers to analyze. To be provided as a merged data
#'   set of the layers that have undergone the copulization treatment by the
#'   `copulize()` function. Given the output  of `copulize()`, for example an
#'   object named `carmon_cop`, it can be accessed via
#'   `merge_layers(carmon_cop$layers)`.
#' @param sel_method The network selection method. Use 'stars' for StARS, 'ric'
#'   for rotational information criterion. Default is 'stars'.
#' @param ... The additional optional arguments to be given for the network
#'   reconstruction procedure, see [huge::huge.mb()] for the network
#'   reconstruction. For additional options for network selection, see
#'   [huge::huge.select()].
#' @param verbose The level of verbosity of the reconstruction process. `0`
#'   suppresses the information output, while `1` and `2` give progressively
#'   increasing amounts of information about the inner computations.
#' @param verbose_inner Whether the inner reconstruction and selection methods
#'   should be verbose or not.
#'
#' @returns This function returns an R list with the following elements:
#' \itemize{
#'   \item `sel_adj` is the adjacency matrix of the final selected network.
#'   \item `net_method` is the chosen network reconstruction method.
#'   \item `sel_method` is the chosen model selection method.
#' }
#' For the additional output elements, please look at [huge::huge()] and at
#' [huge::huge.select()].
#'
#' @noRd
#'
reconstruct_mb <- function(layers, sel_method = NULL, ..., verbose = FALSE,
                            verbose_inner = FALSE) {
    if (is.null(sel_method) && !("criterion" %in% names(list(...)))) {
        sel_method <- "stars"
    } else if (is.null(sel_method) && "criterion" %in% names(list(...))) {
        args <- list(...)
        sel_method <- args$criterion
    } else if ("criterion" %in% names(list(...))) {
        warning("Selection method was provided twice: as sel_method and as
    criterion. sel_method will overwrite criterion")
    }
    if (!(sel_method %in% c("stars", "ric"))) {
        stop("sel_method for Meinshausen & Buhlmann should be one between
    'stars', or 'ric'")
    }
    if (verbose > 0 & verbose < 2) {
        message("Reconstructing network with neighborhood selection",
                    ", selecting the optimal one with ", sel_method, "....")
        flush.console()
    }
    # Build mb networks with huge
    valid_args <- filter_args(huge::huge.mb, list(...))
    valid_args$x <- layers
    valid_args$verbose <- verbose_inner
    rec <- do.call(huge::huge.mb, valid_args)
    rec$data <- layers
    rec$method <- "mb"
    if (!is.null(valid_args$sym)) {
        rec$sym <- valid_args$sym
    } else {
        rec$sym <- "or"
    }
    # Select network
    valid_args <- filter_args(huge::huge.select, list(...))
    valid_args$est <- rec
    valid_args$criterion <- sel_method
    valid_args$verbose <- verbose_inner
    rec <- do.call(huge::huge.select, valid_args)
    rec$sel_adj <- rec$refit
    rec$refit <- NULL
    if (verbose > 0 & verbose < 2) {
        message("Optimal network selected!")
        flush.console()
    }
    rec$sel_method <- sel_method
    return(rec)
}
