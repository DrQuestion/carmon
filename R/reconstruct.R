#' Reconstruct a multi-omics network from a list of copulized layers
#'
#' Reconstruct a multi-omics network from a list of copulized layers with a
#' chosen network reconstruction method. The default method is
#' \emph{collaborative graphical regression}.
#'
#' `reconstruct()` uses \emph{collaborative graphical lasso} ("coglasso") as a
#' default engine to reconstruct the multi-omics network, as the method was
#' specifically developed for the multi-omics scenario. `carmon` also implements
#' three classic alternatives to "coglasso": \emph{graphical lasso}, neighborhood
#' selection (as designed by Meinshausen and Buhlmann), and Pearson's
#' correlation networks. The computational engine mainly used for these
#' alternative options is the `huge` R package for network reconstruction, with
#' a couple of small exceptions. Each one of these methods comes with its
#' tailored model selection procedures. For "coglasso", for example, it is an
#' StARS procedure extended to the multiple hyperparameters of coglasso,
#' \emph{XStARS}, while for the other methods we suggest using the traditional
#' \emph{StARS} strategy.
#'
#' @param layers The omics layers to analyze. To be provided as a named R
#'   list of data sets that have undergone the copulization treatment by the
#'   `copulize()` function. Given the output  of `copulize()`, for example an
#'   object named `carmon_cop`, it can be accessed via `carmon_cop$layers`.
#' @param net_method The network reconstruction method to use. The four methods
#'   currently available are: "coglasso" for collaborative graphical lasso,
#'   "glasso" for graphical lasso, "mb" for the Meinshausen-Buhlmann
#'   neighborhood selection, and "correlation" for a thresholded Pearson's
#'   correlation network. The default method is "coglasso".
#' @param sel_method The network selection method. Each reconstruction procedure
#'   has its own model selection procedures available. Here is the list of them:
#'   * for `net_method` being "coglasso": "xstars" for eXtended StARS, "xestars"
#'   for eXtended  Efficient StARS, and "ebic" for extended bayesian information
#'   criterion. Default is "xestars".
#'   * for `net_method` being "glasso": "stars" for StARS, "ric" for rotational
#'   information criterion, and "ebic" for for extended bayesian information
#'   criterion. Default is "stars".
#'   * for `net_method` being "mb" or "correlation": "stars" for StARS, "ric"
#'   for rotational information criterion. Default is "stars".
#' @param ... The additional optional arguments to be given for the network
#'   reconstruction procedure. The available arguments depend on the chosen
#'   network reconstruction and network selection methods. If using "coglasso"
#'   (default option), see [coglasso::bs()] for both reconstruction and
#'   selection arguments. If reconstructing with "glasso", "mb", or
#'   "correlation" without setting `cor_cutoff` or `cor_quant` see,
#'   respectively, [huge::huge.glasso()], [huge::huge.mb()], or
#'   [huge::huge.ct()]. For additional options for network selection from these
#'   last three reconstruction methods, see [huge::huge.select()].
#' @param cor_cutoff Optional for `net_method = "correlation"`. The cutoff
#'   value for the absolute Pearson's correlation network. Any edge with an
#'   absolute correlation below the cutoff is excluded from the final network.
#'   Not used by default, as the cutoff is generated by internal calculations.
#' @param cor_quant Optional for `net_method = "correlation"`, to set as an
#'   alternative to `cor_cutoff`. Determine the cutoff of correlation based on
#'   the top percentile indicated by the user. For example, `cor_quant = 0.2`
#'   would set as a correlation cutoff the 20th percentile of the absolute
#'   Pearson's correlation values, ordered from highest to lowest. Not used by
#'   default, as the cutoff is generated by internal calculations.
#' @param minimal_output Logical. Set to TRUE to get only a minimal output from
#'   the `reconstruct()` function, which differs depending on the network
#'   reconstruction method.
#' @param verbose The level of verbosity of the reconstruction process. `0`
#'   suppresses the information output, while `1` and `2` give progressively
#'   increasing amounts of information about the inner computations happening
#'   inside `reconstruct()`.
#'
#' @returns `reconstruct()` returns an object of `S3` class `carmon_rec`. The
#' elements it contains depend on the chosen network reconstruction and
#' selection strategies, but the main elements are shared by all methods. \cr
#' These shared elements are:
#' \itemize{
#'   \item `sel_adj` is the adjacency matrix of the final selected network.
#'   \item `net_method` is the chosen network reconstruction method.
#'   \item `sel_method` is the chosen model selection method.
#'   \item `reconstruct_call` is the matched call.
#' }
#'
#' Moreover, when choosing "coglasso" or "glasso" as network reconstruction
#' method, `reconstruct()` also returns:
#'
#' \itemize{
#'   \item `sel_icov` is the inverse covariance matrix of the final selected
#'     network.
#' }
#'
#' Otherwise, if choosing "correlation", it returns:
#'
#' \itemize{
#'   \item `cor` is the Pearson's correlation matrix of the final selected
#'     network.
#' }
#'
#' When `minimal_output` is set to TRUE, these are also the only elements
#' returned in the object of class `carmon_rec` given by `reconstruct()`. For
#' the non minimal output elements, please look at [coglasso::bs()] for
#' `net_method = "coglasso"`. For the other three methods, look at
#' [huge::huge()] and at [huge::huge.select()].
#'
#' @export
#'
#' @examples
#' # To reconstruct the multi-omics network, it is first necessary to copulize
#' # the input data with copulize(), then provide the normally distributed
#' # omics layers to reconstruct().
#' copulized <- copulize(multi_omics_micro)
#' rec <-  reconstruct(copulized$layers, net_method = "correlation",
#'   cor_quant = 0.5, verbose = FALSE)
#'
#' # To make a carmon object out of these two:
#' c_obj <- assemble_carmon_obj(copulized, rec)
#'
reconstruct <- function(layers, net_method = "coglasso", sel_method = NULL, ..., cor_cutoff = NULL, cor_quant = NULL, minimal_output = FALSE, verbose = FALSE) {
  # ENCOURAGE IN HELP FUNCTION NOT TO USE THE OPTIONAL PARAMETERS THAT ARE
  # CONTROLLED ALREADY BY PARAMETERS OF THE RECONSTRUCT FUNCTION
  #
  # SHALL I STRIP DOWN THE OUTPUT TO THE STRICT ESSENTIALS?
  call <- match.call()

  p <- sapply(layers, ncol)

  verbose_inner <- FALSE
  if(verbose > 1){
    verbose_inner <- TRUE
  }
  if (verbose) {
    cat("***********Beginning network reconstruction***********")
    cat("\n")
    flush.console()
  }
  layers <- merge_layers(layers)
  if (net_method == "coglasso") {
    if (is.null(sel_method)) {
      sel_method <- "xestars"
    } else if ("method" %in% names(list(...))){
      warning("Selection method was provided twice: as sel_method and as method. sel_method will overwrite method")
    }
    if (!(sel_method %in% c("xstars", "xestars", "ebic"))) {
      stop("sel_method for coglasso should be one between 'xstars', 'xestars', or 'ebic'")
    }
    if (verbose > 0 & verbose < 2) {
      mes <- paste(c("Reconstructing network with ", net_method, ", selecting the optimal one with ", sel_method, "...."), collapse = "")
      cat(mes, "\r")
      flush.console()
    }
    valid_args <- filter_args(coglasso::bs, list(...))
    valid_args$data <- layers
    valid_args$p <- p
    valid_args$method <- sel_method
    valid_args$verbose <- verbose_inner
    if (length(p) > 2) {
      # Until multiple data sets issue is solved for D > 2, c is forced to 0
      if ("c" | "nc" | "c_max" | "c_min_ratio" %in% names(valid_args)) {
        warning("Argument 'c' was detected with more than two omics layers. coglasso can be run only for c = 0 with more than two layers.")
      }
      valid_args$c <- 0
      rec <- do.call(coglasso::bs, valid_args)
    } else {
      rec <- do.call(coglasso::bs, valid_args)
    }
    if (verbose > 0 & verbose < 2) {
      mes <- paste(c("Reconstructing network with ", net_method, ", selecting the optimal one with ", sel_method, "....done"), collapse = "")
      cat(mes, "\r")
      cat("\n")
      flush.console()
    }
  } else if (net_method == "glasso") {
    if (is.null(sel_method) && !("criterion" %in% names(list(...)))) {
      sel_method <- "stars"
    } else if (is.null(sel_method) && "criterion" %in% names(list(...))) {
      args <- list(...)
      sel_method <- args$criterion
    } else if ("criterion" %in% names(list(...))){
      warning("Selection method was provided twice: as sel_method and as criterion. sel_method will overwrite criterion")
    }
    if (!(sel_method %in% c("stars", "ric", "ebic"))) {
      stop("sel_method for glasso should be one between 'stars', 'ric', or 'ebic'")
    }
    if (verbose > 0 & verbose < 2) {
      mes <- paste(c("Reconstructing network with ", net_method, ", selecting the optimal one with ", sel_method, "...."), collapse = "")
      cat(mes, "\r")
      flush.console()
    }
    # Build glasso networks with huge
    valid_args <- filter_args(huge::huge.glasso, list(...))
    valid_args$x <- layers
    valid_args$verbose <- verbose_inner
    rec <- do.call(huge::huge.glasso, valid_args)
    rec$data <- layers
    rec$method <- "glasso"
    # Select network
    valid_args <- filter_args(huge::huge.select, list(...))
    valid_args$est <- rec
    valid_args$criterion <- sel_method
    valid_args$verbose <- verbose_inner
    rec <- do.call(huge::huge.select, valid_args)
    rec$sel_adj <- rec$refit
    rec$refit <- NULL
    rec$sel_icov <- rec$opt.icov
    rec$opt.icov <- NULL
    if (verbose > 0 & verbose < 2) {
      mes <- paste(c("Reconstructing network with ", net_method, ", selecting the optimal one with ", sel_method, "....done"), collapse = "")
      cat(mes, "\r")
      cat("\n")
      flush.console()
    }
  } else if (net_method == "correlation") {
    if (is.null(cor_quant) && is.null(cor_cutoff)) {
      # Use huge correlation thresholding
      if (is.null(sel_method) && !("criterion" %in% names(list(...)))) {
        sel_method <- "stars"
      } else if (is.null(sel_method) && "criterion" %in% names(list(...))) {
        args <- list(...)
        sel_method <- args$criterion
      } else if ("criterion" %in% names(list(...))){
        warning("Selection method was provided twice: as sel_method and as criterion. sel_method will overwrite criterion")
      }
      if (!(sel_method %in% c("stars", "ric"))) {
        stop("sel_method for correlation should be one between 'stars' or 'ric'")
      }
      if (verbose > 0 & verbose < 2) {
        mes <- paste(c("Reconstructing network with correlation thresholding, selecting the optimal one with ", sel_method, "...."), collapse = "")
        cat(mes, "\r")
        flush.console()
      }
      # Build correlation networks with huge
      valid_args <- filter_args(huge::huge.ct, list(...))
      valid_args$x <- layers
      valid_args$verbose <- verbose_inner
      rec <- do.call(huge::huge.ct, valid_args)
      rec$data <- layers
      rec$method <- "ct"
      # Select network
      valid_args <- filter_args(huge::huge.select, list(...))
      valid_args$est <- rec
      valid_args$criterion <- sel_method
      valid_args$verbose <- verbose_inner
      rec <- do.call(huge::huge.select, valid_args)
      rec$sel_adj <- rec$refit
      rec$refit <- NULL
      rec$cor <- stats::cor(layers)
      if (verbose > 0 & verbose < 2) {
        mes <- paste(c("Reconstructing network with correlation thresholding, selecting the optimal one with ", sel_method, "....done"), collapse = "")
        cat(mes, "\r")
        cat("\n")
        flush.console()
      }
    } else {
      if (verbose) {
        cat("Reconstructing network with Pearson's correlation....")
        cat("\n")
        flush.console()
      }
      # Directly estimate one correlation network
      cor_mat <- stats::cor(layers)
      rec <- list()
      rec$sel_adj <- cor_mat
      rec$cor <- cor_mat
      diag(rec$sel_adj) <- 0
      if (!is.null(cor_quant)) {
        cor_quant <- cor_quant
        limit_position <- cor_quant * ((nrow(rec$sel_adj)^2) - nrow(rec$sel_adj))
        cor_cutoff <- sort(abs(rec$sel_adj), decreasing = TRUE)[limit_position]
      }
      if (verbose) {
        mes <- paste(c("Correlation cutoff is ", cor_cutoff), collapse = "")
        cat(mes)
        cat("\n")
        flush.console()
      }
      above_cutoff <- which(abs(rec$sel_adj) >= cor_cutoff)
      rec$sel_adj[above_cutoff] <- 1
      rec$sel_adj[rec$sel_adj!=1] <- 0
      if (verbose) {
        cat("Reconstructing network with Pearson's correlation....done")
        cat("\n")
        flush.console()
      }
    }
  } else if (net_method == "mb") {
    if (is.null(sel_method) && !("criterion" %in% names(list(...)))) {
      sel_method <- "stars"
    } else if (is.null(sel_method) && "criterion" %in% names(list(...))) {
      args <- list(...)
      sel_method <- args$criterion
    } else if ("criterion" %in% names(list(...))){
      warning("Selection method was provided twice: as sel_method and as criterion. sel_method will overwrite criterion")
    }
    if (!(sel_method %in% c("stars", "ric"))) {
      stop("sel_method for Meinshausen & Buhlmann should be one between 'stars', or 'ric'")
    }
    if (verbose > 0 & verbose < 2) {
      mes <- paste(c("Reconstructing network with ", net_method, ", selecting the optimal one with ", sel_method, "...."), collapse = "")
      cat(mes, "\r")
      flush.console()
    }
    # Build mb networks with huge
    valid_args <- filter_args(huge::huge.mb, list(...))
    valid_args$x <- layers
    valid_args$verbose <- verbose_inner
    rec <- do.call(huge::huge.mb, valid_args)
    rec$data <- layers
    rec$method <- "mb"
    if (!is.null(valid_args$sym)) {
      rec$sym <- valid_args$sym
    } else {
      rec$sym <- "or"
    }
    # Select network
    valid_args <- filter_args(huge::huge.select, list(...))
    valid_args$est <- rec
    valid_args$criterion <- sel_method
    valid_args$verbose <- verbose_inner
    rec <- do.call(huge::huge.select, valid_args)
    rec$sel_adj <- rec$refit
    rec$refit <- NULL
    if (verbose > 0 & verbose < 2) {
      mes <- paste(c("Reconstructing network with ", net_method, ", selecting the optimal one with ", sel_method, "....done"), collapse = "")
      cat(mes, "\r")
      cat("\n")
      flush.console()
    }
  }
  if (minimal_output) {
    non_minimal <- which(!(names(rec) %in% c("sel_adj", "sel_icov", "cor")))
    rec[non_minimal] <- NULL
  } else {
    rec$method <- NULL
  }

  rec$net_method <- net_method
  rec$sel_method <- sel_method
  rec$reconstruct_call <- call
  class(rec) <- "carmon_rec"
  if (verbose) {
    cat("***********Network reconstruction complete************")
    cat("\n\n")
    flush.console()
  }
  return(rec)
}

# DEVELOP: ####
#A MAKE FUNCTION THAT CHECKS THAT NUMBER OF LAYERS IS CONSTISTENT ACROSS layers,
#  p, omics AND marginals                                                       X
#A ADJUST COPULIZE TO ACCEPT DATAFRAMES/TABLES/MATRIXES                         X
#A FINISH WRITING THE ELLIPSIS MENAGEMENT                                       X
#A ADD AN MB OPTION                                                             X
#A FINALIZE THE RECONSTRUCT FUNCTION                                            X
#A EXTRACT NETWORK FUNCTION                                                     X
#A PLOT FUNCTION                                                                X
#A ADJUST GET NETWORK FUNCTION TO MISSING COL NAMES AND WRONG CLASSES           X
#A MODIFY PLOT TO ACCEPT OMICS INFO FOR LEGEND                                  X
#A MATCH CALL FOR CARMON() FUNCTION                                             X
#A MANAGE VERBOSE FOR CARMON() FUNCTION, DECIDE WHETHER TO PRINT STATUS MESSAGES
#  OR NOT. Verbose levels?                                                      X
#A START REASONING ON BASIC NETWORK ANALYSIS MODULES, ONCE NETWORKS ARE OBTAINEDX
#A PLOT OF REPORT, BARS OF SAME COLOR AS NETWORK NODES, FILLS AND FRAMES        X
#A MODIFY PLOT TO DISPLAY HOT NODES RESULTING FROM THE ANALYSIS                 X
#A ADJUST VERBOSE COGLASSO X(E)STARS ETC.                                       X
#A MAKE SEPARATE FUNCTION CENTRALITY REPORT TO EXTRACT THE REPORT IN TABLE
#  FORMAT, ALSO TO BE USED SEPARATELY ON A CARMON OBJECT                        X
#A SOLVE MISTERY OF PLOT_REPORT.CARMON --> WHY NOT A METHOD?                    X
#A WRAPPING FUNCTION FOR COPULIZE + RECONSTRUCT + GET_NETWORK + ANALYZE
#  (optional) + PLOT(optional)                                                  X
#A PRINT FUNCTION LIKE COGLASSO, SEPARATE BY ASTERISKS                          x
#A CHECK IF YOU CAN SET PAR() IN AN R PACKAGE CHANGING GLOBAL PARAMS            X
#A ADD WEIGHTS TO PLOT NETWORK                                                  X
#A CHECK INTEGRITY OF INFORMATION FLOW AMONG FUNCTIONS OF THE PACKAGE (E.G.
#  LAYERS AS LIST/DATAFRAME, BUT THERE MUST BE MORE. IMAGINE THE FLOW BEGINNING
#  TO END.)                                                                     X
#A QUARTILE EDGE TYPE                                                           X
#A PLOT() WITH SAME LAYOUT BUT WEIGHED -> CHECK IF STILL MESSY                  X
#A MAKE DATA FOR TESTING AND EXAMPLES                                           X
#A MAKE AN IMAGE() METHOD
#A CHANGE PRINT MESSAGE TO ALLOCATE PARAMETERS COMBINATIONS AND THE ONES
#  SELECTED
#A COGLASSO: CORRECT DESCRIPTION MESSAGE
#A COGLASSO: CHECK THAT PLOTTING MODULE BEHAVES CORRECTLY WITH WEIGHTS
#A COGLASSO: RELEASE 2.0 FOR ALLOWING OFFICIAL ACCESS TO CARMON
#A UPDATE AND RELEASE COGLASSO
#
#
#B INVERT FINE-GRAINED - COARSE DIRECTION OF LAMBDA GENERATION FOR COGLASSO. WE
#  END UP SELECTING SPARSE ANYWAYS, WE MIGHT AS WELL EXPLORE THERE MORE,
#  ESPECIALLY FOR SMALLER NETWORKS.                                             X
#B FINISH IMPLEMENTING THE METHYLOME INTEGRATION SUITE (carmon_future)
#B CHECK THAT COPULIZED METHYLATION DATA ARE STANDARD NORMAL!!!! THERE MIGHT BE
#  ISSUES OF DIMENSIONS AND PARAMETERS!!!
#B STABILITY TO MEASURE ACCURACY OF CENTRALITY MEASURE
#B Create internal data structure that contains omics list, access it internally
#  through the check functions that need it.
#B SUPPORT FOR NPN HUGE FUNCTIONS IF VERY HIGH DIMENSION
#B CONTROL EBIC LAMBDA RANGE??
#B INTERACTIVE NETWORK VISUALIZATION
#
#
#C PLOTTING MODULE WITH CUSTOMIZED SVG ICONS
#C ADD FUNCTION THAT ALLOWS TO REPEAT RECONSTRUCTION FROM ANY REQUIRED STEP,
#  FROM BUILDING TO SELECTION WITH A DIFFERENT METHOD, THAT WORKS ONLY WHEN
#  OUTPUT IS NON-MINIMAL
#C OPTIONAL CYTOSCAPE OUTPUT
#C START REASONING ON A GUI
#C ADD FUSED GLASSO SUPPORT?
#C WGCNA-LIKE NETWORK ANALYSIS?


# TEST: ####
#A FINISH WRITING TESTS TO THE HELPERS FUNCTIONS TO CHECK AND MERGE LAYERS      X
#A TEST COPULIZE FOR NB (dimensions etc.)                                       X
#A WRITE TESTS FOR THE RECONSTRUCT FUNCTION
#A WRITE TESTS FOR COPULIZE
#A WRITE TESTS FOR VERBOSITY
#A CHECK WHICH OTHER FUNCTIONS NEED TESTING
#B FIND METHYL-OTHER DATASET TO TEST BB (carmon_future)
#B TEST COPULIZE FOR BB (dimensions etc.)


# DOCS: ####
#A FINALIZE WRITING DOCUMENTATION
#A SPECIFY THAT PARAMETER COPULA IN COPULIZER IS JUST A PLACEHODER FOR FUTURE   X
#A IMPLEMENTATION OF NEW FUNCTIONALITIES
#A MAKE SURE TO MENTION THAT DATA SHOULD NOT BE NORMALIZED GODDAMMIT            X
#A DOCUMENT DATA                                                                X
#A WRITE EXAMPLES
#A ADJUST THE HELP RD FILE PUTTING ELLIPSIS IN RIGHT SPOT, THEN DELETE ROXYGEN
#  SKELETON FROM ABOVE CARMON()


