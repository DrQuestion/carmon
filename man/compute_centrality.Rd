% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analyse.R
\name{compute_centrality}
\alias{compute_centrality}
\title{Find key nodes in a \code{carmon} network}
\usage{
compute_centrality(
  carmon_obj,
  measures = "dbce",
  max_candidates = NULL,
  quant = NULL,
  scaled = TRUE,
  verbose = FALSE
)
}
\arguments{
\item{carmon_obj}{The object of \code{S3} class \code{carmon}.}

\item{measures}{A string of characters, each one representing one of four
possible centrality measures implemented: \code{"d"} stands for degree
centrality, \code{"b"} for betweenness centrality, \code{"c"} for closeness
centrality, and \code{"e"} for eigenvector centrality. Default is \code{"dbce"}, all
the four measures.}

\item{max_candidates}{What is the highest amount of nodes that can be
highlighted by each measure, \emph{before} finding the consensus? Default
is 20. When given together with the \code{quant} argument, it overrides the
\code{quant} argument when \code{max_candidates} is smaller than the chosen quantile,
it is overrode by \code{quant} in the opposite case.}

\item{quant}{What is the top percentile of nodes that can be highlighted by
each measure, \emph{before} finding the consensus? Default is the top 5\%.
When given together with the \code{max_candidates} argument, it overrides the
\code{max_candidates} argument when the amount of nodes in the
chosen top percentile is smaller than the chosen maximum amount of
candidate nodes, it is overrode by \code{max_candidates} in the opposite case.}

\item{scaled}{Logical, whether to compute centrality measures as
0-1 scaled values. Defaults to TRUE.}

\item{verbose}{The level of verbosity of the centrality analysis. \code{0}
suppresses the information output, while \code{1} and \code{2} give progressively
increasing amounts of information about the inner computations happening
inside the analysis.}
}
\value{
\code{compute_centrality()} returns an object of \code{S3} class \code{carmon},
consisting of the input \code{carmon_obj} enriched of two new elements:
\itemize{
\item \code{report} an R data frame. The rows correspond to the nodes identified to
be central by the analysis, and they are ordered based on how large is
the consensus among the different measures. The data frame has 6 columns: \cr
\emph{candidate}, the name of the central node; \cr
\emph{degree}, the degree centrality of the node; \cr
\emph{betweenness}, the betweenness centrality of the node; \cr
\emph{closeness}, the closeness centrality of the node; \cr
\emph{eigenvector}, the eigenvector centrality of the node; and \cr
\emph{central for}, the a string reporting the first letter of all the
measures according to which the node is central for.
\item \code{measures_list} an R named list of as many elements as the number of
chosen centrality measures, the name of each element being the associated
centrality measure. Each element is a named numerical vector, containing
the measures of the top central nodes identified in the analysis. The
name of each element of the vectors is the name of the node associated to
the reported measure.
}
}
\description{
Find the top central nodes according to multiple centrality measures of
choice Use a consensus of multiple centrality measures to identify nodes that could
be important in the network obtained through \code{carmon}
}
\examples{
# compute_centrality() needs an object of S3 class "carmon" as an input. The
# following line quickly obtains one.
c_obj <- carmon(multi_omics_small, net_method = "correlation",
                cor_quant = 0.25, analysis = FALSE, verbose = FALSE)
# Then to perform the consensus centrality analysis:
c_obj <- compute_centrality(c_obj)

}
